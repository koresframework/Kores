<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kores Framework Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="What-is.html"><strong aria-hidden="true">1.</strong> What is</a></li><li class="chapter-item expanded "><a href="Getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kores Framework Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="what-is"><a class="header" href="#what-is">What is</a></h1>
<p>Kores Framework (named as CodeAPI earlier) is a library that provides AST (<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>) for Java and JVM classes and modules. With Kores AST Definitions you can produce <strong>Java Source Code</strong> using <a href="https://github.com/koresframework/Kores-SourceWriter"><strong>Kores-SourceWriter</strong></a> transpiler and <strong>JVM Bytecode</strong> using <a href="https://github.com/koresframework/Kores-BytecodeWriter"><strong>Kores-BytecodeWriter</strong></a> compiler.</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>Initially, Kores was a toy project to learn JVM Bytecode and create a common structure for compile-time and runtime code generation, focused on <strong>Annotation Processors</strong>. Later, Kores evolved to more likely a JVM Bytecode compiler ecosystem, more focused on <strong>JVM Bytecode Generation</strong> than in <strong>Java Source Generation</strong>.</p>
<p>Kores bytecode generation module tries to generate bytecode as close as possible to <strong>javac</strong>, with some exceptions, like <a href="https://stackoverflow.com/a/48603069"><strong>not generating inner class definition for every used inner class</strong></a> as specified in second paragraph of <a href="https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jvms-4.7.6">JVMS 4.7.6</a>. There is likely no popular JVM Implementation that does check for this (or no one of them check at all) or use this kind of information for something in fact, this is only a specification that is followed by <strong>javac</strong>.</p>
<h2 id="projects-that-uses-kores"><a class="header" href="#projects-that-uses-kores">Projects that uses Kores</a></h2>
<ul>
<li>
<p><a href="https://github.com/ProjectSandstone/EventSys">EventSys</a></p>
<ul>
<li>A dynamic property base event system written on top of Kores</li>
</ul>
</li>
<li>
<p><a href="https://github.com/JonathanxD/CodeProxy">CodeProxy</a></p>
<ul>
<li>A Proxy generator written on top of Kores, the key difference between Java proxies is that CodeProxies can extend classes.</li>
</ul>
</li>
<li>
<p><a href="https://github.com/JonathanxD/AdapterHelper">AdapterHelper</a></p>
<ul>
<li>A set of utilities to help with creation, registration and management of Adapters, some features requires Kores, such as deep instance adapting.</li>
</ul>
</li>
<li>
<p><a href="https://github.com/FireflyLang/firefly-compiler">FireflyLang Compiler</a></p>
<ul>
<li>A proof-of-concept language that implements type-reification, traits, rules, and so on.</li>
</ul>
</li>
</ul>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<p>Kores could be used in compilers, runtime code generators, compile-time code generators (and mixed generators through the common AST). However, Kores is not focused on providing instrumentation of already compiled classes. There was an attempt to provide this functionality through <a href="https://github.com/koresframework/Kores-BytecodeReader">Kores-BytecodeReader</a> but maintenance and implementation stopped to focus on code generation.</p>
<p>Also, Kores AST could be serialized and deserialized using <a href="https://github.com/Kotlin/kotlinx.serialization">Kotlinx Serialization Library</a>, providing easy way to compilers store and retrieve metadata about classes, including method inlining and Type Reification without Bytecode Manipulation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this guide we will be using Kores base library and Kores-BytecodeWriter and Kores-SourceWriter modules. Kores base module provides AST, but can't produce code by itself.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Kores uses GitHub packages to provide artifacts, and since <a href="https://github.community/t/download-from-github-package-registry-without-authentication/14407/129">Github does not support unauthenticated downloads yet</a>, you will need to generate a <a href="https://github.com/settings/tokens">Personal Access Token (PAT)</a> with <code>read:packages</code> permission and configure it in <code>gradle.properties</code> inside <code>$HOME/.gradle/gradle.properties</code>:</p>
<pre><code class="language-properties">USERNAME=GITHUB_USERNAME
TOKEN=PAT
</code></pre>
<p>Then configure the <code>build.gradle</code> to include Kores Repositories and dependecies:</p>
<pre><code class="language-gradle">def GITHUB_USERNAME = project.findProperty(&quot;USERNAME&quot;) ?: System.getenv(&quot;USERNAME&quot;)
def GITHUB_PAT = project.findProperty(&quot;TOKEN&quot;) ?: System.getenv(&quot;TOKEN&quot;)

repositories {
    mavenCentral()
    maven {
        url &quot;https://maven.pkg.github.com/jonathanxd/jwiutils&quot;
        credentials {
            username = GITHUB_USERNAME
            password = GITHUB_PAT
        }
    }
    maven {
        url &quot;https://maven.pkg.github.com/jonathanxd/bytecodedisassembler&quot;
        credentials {
            username = GITHUB_USERNAME
            password = GITHUB_PAT
        }
    }
    maven {
        url &quot;https://maven.pkg.github.com/koresframework/kores&quot;
        credentials {
            username = GITHUB_USERNAME
            password = GITHUB_PAT
        }
    }
    maven {
        url &quot;https://maven.pkg.github.com/koresframework/kores-bytecodewriter&quot;
        credentials {
            username = GITHUB_USERNAME
            password = GITHUB_PAT
        }
    }
    maven {
        url &quot;https://maven.pkg.github.com/koresframework/kores-sourcewriter&quot;
        credentials {
            username = GITHUB_USERNAME
            password = GITHUB_PAT
        }
    }
}

dependencies {
    implementation(&quot;com.koresframework:kores:4.2.1.base&quot;)
    implementation(&quot;com.koresframework:kores-bytecodewriter:4.2.1.bytecode&quot;)
    implementation(&quot;com.koresframework:kores-sourcewriter:4.2.1.source&quot;)
}
</code></pre>
<blockquote>
<p>Kores team (that consists of only one member) is studying alternatives to artifact publication (jitpack is not an option until OpenJDK 17 support). At the moment, only Github packages is supported. Jitpack support was not entirely dropped, but since it is not able to build some modules (because now Kores requires Java 16 at least), we are not officially using it.</p>
</blockquote>
<h2 id="your-first-class"><a class="header" href="#your-first-class">Your first class</a></h2>
<p>Kores provides 5 (6 in recent versions with Record) different kinds of class declaration:</p>
<ul>
<li>ClassDeclaration</li>
<li>InterfaceDeclaration</li>
<li>EnumDeclaration</li>
<li>AnonymousClassDeclaration</li>
<li>AnnotationDeclaration</li>
</ul>
<p>Let's get started with the class declaration:</p>
<pre><code class="language-kotlin">val personDeclaration = ClassDeclaration.Builder.builder()
    .name(&quot;Person&quot;)
    .build()
</code></pre>
<p>Now we are going to use the Kores-SourceWriter to render this declaration into a Java class:</p>
<pre><code class="language-kotlin">val sourceGenerator = PlainSourceGenerator()
val source = sourceGenerator.process(personDeclaration)
println(source)
</code></pre>
<p>The result would be:</p>
<pre><code class="language-java">public class Person {
}
</code></pre>
<p>By default, Kores uses <code>public</code> modifier for all types, to generate a package-private class you need to use <code>PACKAGE_PRIVATE</code> modifier:</p>
<pre><code class="language-kotlin">val personDeclaration = ClassDeclaration.Builder.builder()
    .modifiers(KoresModifier.PACKAGE_PRIVATE)
    .name(&quot;Person&quot;)
    .build()
</code></pre>
<p>Which renders to:</p>
<pre><code class="language-java">class Person {
}
</code></pre>
<h3 id="adding-some-fields"><a class="header" href="#adding-some-fields">Adding some fields</a></h3>
<p>Adding new fields are very simple:</p>
<pre><code class="language-kotlin">val nameFieldDeclaration = FieldDeclaration.Builder.builder()
    .modifiers(KoresModifier.PRIVATE, KoresModifier.FINAL)
    .type(Types.STRING)
    .name(&quot;name&quot;)
    .build()

val personDeclaration = ClassDeclaration.Builder.builder()
    .name(&quot;Person&quot;)
    .fields(nameFieldDeclaration)
    .build()

val sourceGenerator = PlainSourceGenerator()
val source = sourceGenerator.process(personDeclaration)

println(source)
</code></pre>
<p>Result:</p>
<pre><code class="language-java">public class Person {

    private final String name;
}
</code></pre>
<h3 id="constructor"><a class="header" href="#constructor">Constructor</a></h3>
<p>Now we need to have a constructor in order to define our field (which is final):</p>
<pre><code class="language-kotlin">val nameFieldDeclaration = FieldDeclaration.Builder.builder()
    .modifiers(KoresModifier.PRIVATE, KoresModifier.FINAL)
    .type(Types.STRING)
    .name(&quot;name&quot;)
    .build()

val constructorDeclaration = ConstructorDeclaration.Builder.builder()
    .build()

val personDeclaration = ClassDeclaration.Builder.builder()
    .name(&quot;Person&quot;)
    .fields(nameFieldDeclaration)
    .constructors(constructorDeclaration)
    .build()

val sourceGenerator = PlainSourceGenerator()
val source = sourceGenerator.process(personDeclaration)

println(source)
</code></pre>
<p>Result:</p>
<pre><code class="language-java">public class Person {

    private final String name;

    public Person() {
    }
}
</code></pre>
<h3 id="declaring-the-field-and-constructor-parameters"><a class="header" href="#declaring-the-field-and-constructor-parameters">Declaring the field and constructor parameters</a></h3>
<p>Now that we have a field and a constructor, we need to define the field value to be the same as the constructor parameter value, first we need the parameter, so let's modify our constructor declaration:</p>
<pre><code class="language-kotlin">val constructorDeclaration = ConstructorDeclaration.Builder.builder()
    .parameters(
        KoresParameter.Builder.builder()
            .type(Types.STRING)
            .name(&quot;name&quot;)
            .build()
    )
    .build()
</code></pre>
<p>And then provide a body for the constructor with the instructions which reads the parameter and sets the field:</p>
<pre><code class="language-kotlin">val constructorDeclaration = ConstructorDeclaration.Builder.builder()
    .parameters(
        KoresParameter.Builder.builder()
            .type(Types.STRING)
            .name(&quot;name&quot;)
            .build()
    )
    .body(MutableInstructions.create(listOf(
        setThisFieldValue(Types.STRING, &quot;name&quot;, accessVariable(Types.STRING, &quot;name&quot;))
    )))
    .build()
</code></pre>
<p>The full code is:</p>
<pre><code class="language-kotlin">val nameFieldDeclaration = FieldDeclaration.Builder.builder()
    .modifiers(KoresModifier.PRIVATE, KoresModifier.FINAL)
    .type(Types.STRING)
    .name(&quot;name&quot;)
    .build()

val constructorDeclaration = ConstructorDeclaration.Builder.builder()
    .parameters(
        KoresParameter.Builder.builder()
            .type(Types.STRING)
            .name(&quot;name&quot;)
            .build()
    )
    .body(MutableInstructions.create(listOf(
        setThisFieldValue(Types.STRING, &quot;name&quot;, accessVariable(Types.STRING, &quot;name&quot;))
    )))
    .build()

val personDeclaration = ClassDeclaration.Builder.builder()
    .name(&quot;Person&quot;)
    .fields(nameFieldDeclaration)
    .constructors(constructorDeclaration)
    .build()

val sourceGenerator = PlainSourceGenerator()
val source = sourceGenerator.process(personDeclaration)

println(source)
</code></pre>
<p>And the result:</p>
<pre><code class="language-java">public class Person {

    private final String name;

    public Person(String name) {
        this.name = name;
    }
}
</code></pre>
<h3 id="your-first-method"><a class="header" href="#your-first-method">Your first method</a></h3>
<p>Now we need a getter in order to retrieve the field value, for this one we will be using the <code>MethodDeclaration</code> class:</p>
<pre><code class="language-kotlin">val getterDeclaration = MethodDeclaration.Builder.builder()
    .publicModifier()
    .type(Types.STRING)
    .name(&quot;getName&quot;)
    .body(MutableInstructions.create(listOf(
        returnValue(accessThisField(Types.STRING, &quot;name&quot;))
    )))
    .build()
</code></pre>
<p>And the full code is:</p>
<pre><code class="language-kotlin">val nameFieldDeclaration = FieldDeclaration.Builder.builder()
    .modifiers(KoresModifier.PRIVATE, KoresModifier.FINAL)
    .type(Types.STRING)
    .name(&quot;name&quot;)
    .build()

val constructorDeclaration = ConstructorDeclaration.Builder.builder()
    .parameters(
        KoresParameter.Builder.builder()
            .type(Types.STRING)
            .name(&quot;name&quot;)
            .build()
    )
    .body(MutableInstructions.create(listOf(
        setThisFieldValue(Types.STRING, &quot;name&quot;, accessVariable(Types.STRING, &quot;name&quot;))
    )))
    .build()

val getterDeclaration = MethodDeclaration.Builder.builder()
    .publicModifier()
    .type(Types.STRING)
    .name(&quot;getName&quot;)
    .body(MutableInstructions.create(listOf(
        returnValue(accessThisField(Types.STRING, &quot;name&quot;))
    )))
    .build()

val personDeclaration = ClassDeclaration.Builder.builder()
    .name(&quot;Person&quot;)
    .fields(nameFieldDeclaration)
    .constructors(constructorDeclaration)
    .methods(getterDeclaration)
    .build()

val sourceGenerator = PlainSourceGenerator()
val source = sourceGenerator.process(personDeclaration)

println(source)
</code></pre>
<p>And the result:</p>
<pre><code class="language-java">public class Person {

    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
</code></pre>
<h3 id="bytecode-generation"><a class="header" href="#bytecode-generation">Bytecode Generation</a></h3>
<p>In this guide we have not used the BytecodeWriter yet, so let's try it:</p>
<pre><code class="language-kotlin">val nameFieldDeclaration = FieldDeclaration.Builder.builder()
    .modifiers(KoresModifier.PRIVATE, KoresModifier.FINAL)
    .type(Types.STRING)
    .name(&quot;name&quot;)
    .build()

val constructorDeclaration = ConstructorDeclaration.Builder.builder()
    .parameters(
        KoresParameter.Builder.builder()
            .type(Types.STRING)
            .name(&quot;name&quot;)
            .build()
    )
    .body(MutableInstructions.create(listOf(
        setThisFieldValue(Types.STRING, &quot;name&quot;, accessVariable(Types.STRING, &quot;name&quot;))
    )))
    .build()

val getterDeclaration = MethodDeclaration.Builder.builder()
    .publicModifier()
    .type(Types.STRING)
    .name(&quot;getName&quot;)
    .body(MutableInstructions.create(listOf(
        returnValue(accessThisField(Types.STRING, &quot;name&quot;))
    )))
    .build()

val personDeclaration = ClassDeclaration.Builder.builder()
    .name(&quot;Person&quot;)
    .fields(nameFieldDeclaration)
    .constructors(constructorDeclaration)
    .methods(getterDeclaration)
    .build()

val sourceGenerator = PlainSourceGenerator()
val source = sourceGenerator.process(personDeclaration)

println(source)

val bytecodeGenerator = BytecodeGenerator()

// bytecodeClasses: Here we have a List&lt;BytecodeClass&gt;, every BytecodeClass stores its declaration 
// and the produced bytecode in the BytecodeClass.bytecode array.
// You can save those bytes and inspect them using bytecode inspection tools like
// Textifier, ASMifier, BytecodeDisassembler, javap or even a decompiler
// The disassembled version is available through BytecodeClass.disassembledCode as well, which uses
// the BytecodeDisassembler tool.
val bytecodeClasses = bytecodeGenerator.process(personDeclaration)

// Create a ClassLoader using the current as a parent loader
// this loader has the utilities to load BytecodeClasses
val loader = CodeClassLoader()
// `define` receives the BytecodeClass list to load, but outputs only one defined class.
// It takes a List because the `process` outputs inner classes as well as anonymous classes,
// that should not be used directly.
// You can define classes individually by looping through every one and calling loader.define
val generatedClass = loader.define(bytecodeClasses)
// generatedClass: Here is the loaded class
</code></pre>
<p>Let see if the class is working:</p>
<pre><code class="language-kotlin">val lookup = MethodHandles.publicLookup()
val constructor = lookup.findConstructor(generatedClass, MethodType.methodType(Void.TYPE, String::class.java))
val getName = lookup.findVirtual(generatedClass, &quot;getName&quot;, MethodType.methodType(String::class.java))
val personInstance = constructor.invokeWithArguments(&quot;Foo&quot;)
val personName = getName.bindTo(personInstance).invokeExact() as String
println(personName)
</code></pre>
<p>Outputs:</p>
<pre><code>Foo
</code></pre>
<h3 id="considerations"><a class="header" href="#considerations">Considerations</a></h3>
<h4 id="additional-type-information"><a class="header" href="#additional-type-information">Additional Type Information</a></h4>
<p>It is important to note that you need to provide a bunch of information, such as field type, variable type, and so on, even though those values are not used in the source code generator, this is needed in order to bytecode generator work. Java VM (JVM) implementations are strongly-typed oriented, even when we start talking about its <code>invokedynamic</code> capabilities. Because of this, the JVM needs to know every type upfront, it includes field types and variable types. At bytecode level, you could have more than one field and variable with the same name but different types.</p>
<p>And, the other important thing to know is that some Kores helper methods are able to &quot;determine&quot; the type based on provided instructions, like the <code>returnValue</code> helper that creates the <code>Return</code> instruction, it takes a <code>TypedInstruction</code> that does have a known type.</p>
<h4 id="jvm-intrinsics"><a class="header" href="#jvm-intrinsics">JVM Intrinsics</a></h4>
<p>Even though there is a bunch of JVM Languages, like <a href="https://www.scala-lang.org">Scala</a>, <a href="https://groovy-lang.org">Groovy</a>, <a href="https://kotlinlang.org">Kotlin</a>, <a href="http://ceylon-lang.org/">Ceylon</a>, <a href="https://golo-lang.org">Golo</a>, <a href="https://gosu-lang.github.io">Gosu</a>, <a href="https://clojure.org">Clojure</a>, <a href="https://github.com/mirah/mirah">Mirah</a>, and Languages that targets JVM like <a href="https://haxe.org">Haxe</a>, and runtime implementations of other languages in JVM, like <a href="https://www.jruby.org">JRuby</a>, <a href="https://www.jython.org">Jython</a>, <a href="https://eta-lang.org">Eta</a>, <a href="https://www.renjin.org">Reijin</a>, <a href="https://github.com/oracle/fastr">FastR</a> and <a href="https://github.com/oracle/graaljs">Graal.js</a> (just to list <strong>some</strong> of them), the majority of JVM implementations (except GraalVM and GraalVM-based ones, which are more polyglot VM implementations) still very Java oriented, in other words, the Class structure is very close to Java needs and VM implementations are very optimized to Java language. So Kores is very Java-oriented as well, it implements AST very likely to what a Java AST would be, but it carries much more information than a regular Java AST carries (like those produced by Lexer and Parser generators).</p>
<p>However, some implementation details are abstracted away in Kores, like anonymous classes and non-static inner classes, as they carry a synthetic constructor that receives the enclosing class (outer type) instance. The other thing that is abstracted is switch-case translation, which have two outcomes: LookupSwitch and TableSwitch, Kores-BytecodeWriter is the one that decides which one to generate. Synthetic method generation for generic classes, concatenation indify, Nest Based Access Control, Lambda InvokeDynamic and Synthetic Methods Generation are also some of the other things that are abstracted and generated automatically by Kores-BytecodeWriter. But all of them are Java-related.</p>
<p>Things that other languages implements, like <strong>inline functions</strong>, <strong>reified generics</strong>, <strong>traits</strong>, <strong>multi-dispatch</strong> are not covered by Kores, instead, other projects that depends on Kores are being developed to cover these cases. This is possible through <strong>Kores Visitors</strong> and the <strong>Builder Pattern</strong> implemented in Kores, which allows you to clone a <strong>Kores AST object</strong>, modify it and build it again. We will be talking about this feature later.</p>
<h4 id="kores-vs-truffle"><a class="header" href="#kores-vs-truffle">Kores vs Truffle</a></h4>
<p>Truffle is a language implementation framework, which aims the GraalVM ecosystem, Kores is an AST for generating Java source code and JVM Bytecode, as well as building the ground for Structure Analysis, Unification of Java Annotation Processor Environment and Java Reflection library, Compilers Implementation, Runtime Code Generators and Compile-Time Code generation.</p>
<p>Kores is a powerful framework to implement JVM Languages, and is being used to implement the <a href="https://github.com/fireflylang">Firefly Language</a>. With Kores, it is very fast to have a functional prototype, the first <a href="https://github.com/FireflyLang/firefly-compiler">Firefly Compiler</a> prototype was written in 1 day. But extra work is needed in order to implement non-standard features (such as inline methods) because the JVM foundation is around Java, even with the nice <code>invokedynamic</code> instruction.</p>
<p>I don't have enough background in Truffle to make any assumptions about it being better or not for language implementation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
